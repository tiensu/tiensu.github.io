<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="format-detection" content="telephone=no" />

    <title>
        Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 3 | ML in Practical
    </title>


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#ffffff" />


    <link rel="stylesheet" href="https://unpkg.com/modern-normalize@0.6.0/modern-normalize.css" />





    <link rel="stylesheet" href="https://tiensu.github.io/style.min.388cbd0ce358245ec0dfcee3b8889b3cc50e2bb8a5b2bcd40f8bd092ebefb81a.css" integrity="sha256-OIy9DONYJF7A387juIibPMUOK7ilsrzUD4vQkuvvuBo=" />




    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function(i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'UA-180180568-1', 'auto');
            ga('set', 'anonymizeIp', true);
            ga('send', 'pageview');
        }
    </script>


</head>

<body>
    <header id="header">

        <script type="application/javascript">
            var doNotTrack = false;
            if (!doNotTrack) {
                (function(i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r;
                    i[r] = i[r] || function() {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date();
                    a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                    a.async = 1;
                    a.src = g;
                    m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
                ga('create', 'UA-180180568-1', 'auto');
                ga('set', 'anonymizeIp', true);
                ga('send', 'pageview');
            }
        </script>

        <div class="header_container">
            <h1 class="sitetitle">
                <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a>
            </h1>
            <nav class="navbar">
                <ul>
                    <li><a href="https://tiensu.github.io/">Home</a></li>

                    <li>
                        <a href="/about/">

                            <span>About</span>
                        </a>
                    </li>

                    <li>
                        <a href="/tags/">

                            <span>Tags</span>
                        </a>
                    </li>

                    <li>
                        <a href="/archives/">

                            <span>Archives</span>
                        </a>
                    </li>

                    <li class="hide-sm"><a href="https://tiensu.github.io/index.xml" type="application/rss+xml">RSS</a></li>
                </ul>
            </nav>
        </div>
        <script>
            MathJax = {
                tex: {
                    inlineMath: [
                        ['$', '$'],
                        ['\\(', '\\)']
                    ],
                    displayMath: [
                        ['$$', '$$'],
                        ['\\[', '\\]']
                    ],
                    processEscapes: true,
                    processEnvironments: true
                },
                options: {
                    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            };

            window.addEventListener('load', (event) => {
                document.querySelectorAll("mjx-container").forEach(function(x) {
                    x.parentElement.classList += 'has-jax'
                })
            });
        </script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    </header>


    <section id="main">
        <article class="post content">
            <h2 class="title">Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 3</h2>
            <div class="post_content">
                <p>Tiếp tục chuỗi các bài viết về CNN, trong bài này mình sẽ chia sẻ với các bạn một số &ldquo;common patterns 7 rules&rdquo; trong việc xây dựng kiến trúc CNN. Nắm rõ những &ldquo;patterns &amp; rules&rdquo; này sẽ giúp các bạn giảm thiếu
                    thời gian và công sức khá nhiều trong các dự án của các bạn!</p>
                <p><strong>3. Common Architectures &amp; Training Patterns</strong></p>
                <p>Qua 2 bài viết trước, chúng ta đã biết, CNN được tạo thành từ 4 loại layers chủ yếu, bao gồm: CONV, POOL, RELU, và FC. Sắp xếp các layers này với nhau theo một thứ tự nhất định ta sẽ một CNN (<em>gọi tên đầy đủ là kiến trúc CNN</em>).</p>
                <p><em><strong>3.1 Layers Patterns</strong></em></p>
                <p>Nói chung, hầu hết các kiến trúc CNN đều có mộ vài lớp CONV và RELU liên tiếp nhau, theo sau bởi lớp POOL. Lặp lại như thế đến khi kích thước của input volumn đủ nhỏ, rồi thêm vào một hoặc nhiều FC layers. Pattern tổng quát như sau:</p>
                <p><strong>INPUT =&gt; [[CONV =&gt; RELU]xM =&gt; POOL?]xN =&gt; [FC =&gt; RELU]xK =&gt; FC</strong></p>
                <p>Ký hiệu <strong>x</strong> ở đây tức là lặp lại 1 hoặc nhiều lần, còn <strong>?</strong> nghĩa là tùy chọn, có thể có hoặc không.</p>
                <p><strong>M, N, K</strong> thường chọn theo các rules sau:</p>
                <ul>
                    <li>0 &lt;= N &lt;= 3</li>
                    <li>M &gt;= 0</li>
                    <li>0 &lt;= K &lt;= 2</li>
                </ul>
                <p>Ví dụ một số kiến trúc CNN áp dụng pattern tổng quát bên trên như sau:</p>
                <ul>
                    <li><strong>INPUT =&gt; FC</strong></li>
                    <li><strong>INPUT =&gt; [CONV =&gt; RELU =&gt; POOL]x2 =&gt; FC =&gt; RELU =&gt; FC</strong></li>
                    <li><strong>INPUT =&gt; [[CONV =&gt; RELU]x2 =&gt; POOL]x3 =&gt; [FC =&gt; RELU]x2 =&gt; FC</strong></li>
                </ul>
                <p>Các kiến trúc CNN kinh điển cũng dựa trên pattern tổng quát này:</p>
                <ul>
                    <li>AlexNet: <strong>INPUT =&gt; [CONV =&gt; RELU =&gt; POOL]x2 =&gt; [CONV =&gt; RELU]x3 =&gt; POOL =&gt; [FC =&gt; RELU =&gt; DO]x2 =&gt; SOFTMAX</strong></li>
                    <li>VGGNet: <strong>INPUT =&gt; [CONV =&gt; RELU]x2 =&gt; POOL =&gt; [CONV =&gt; RELU]x2 =&gt; POOL =&gt; [CONV =&gt; RELU]x3 =&gt; POOL =&gt; [CONV =&gt; RELU]x3 =&gt; POOL =&gt; [FC =&gt; RELU =&gt; DO]x2 =&gt; SOFTMAX</strong></li>
                </ul>
                <p>Một cách khái quát, chúng ta sẽ áp dụng các kiến trúc CNN sâu khi gặp bài toán phức tạp, nhiều labels, các đối tượng thay đổi không có quy luật. Sử dụng nhiều CONV layers trước khi áp dụng POOL layer cho phép các CONV layers học được các
                    <code>complex features</code> trước khi áp dụng POOL layer để giảm kích thước của input volumn.</p>
                <p>Như đã đề cập ở bài trước, một số kiến trúc CNN đã loại bỏ hoàn toàn các POOL layers phía sau CONV layers, chỉ sử dụng CONV layers để giảm kích thước của input volumn. Hơn nữa, các FC layers ở cuối cũng không còn được sử dụng, thay vào
                    đó là <code>average pooling</code>. <em>GoogLeNet, ResNet, SqueezeNet</em> là những kiến trúc sử dụng cách này. Kết quả là giảm số lượng tham số của CNN và thời gian train cũng ngắn hơn.</p>
                <p>Đặc biệt hơn, <a href="https://arxiv.org/abs/1409.4842">GoogLeNet</a> còn áp dụng đồng thời 3 loại filters có kích thước khác nhau (<em>1x1, 3x3, 5x5</em>) tại cùng 1 vị trí trong kiến trúc để học <code>multi-level features</code>. Những
                    kiến trúc kiểu như này được coi là công nghệ tiên tiến trong lĩnh vực DL.</p>
                <p><em><strong>3.2 Quy tắc ngón tay cái</strong></em></p>
                <p>Trong phần này, chúng ta sẽ cùng xem xét một số rules khi xây dựng CNN model.</p>
                <ul>
                    <li><em><strong>Rule 1</strong></em></li>
                </ul>
                <p>Đầu tiên, images đưa vào CNN nên có chiều rộng và chiều cao bằng nhau (<em>square</em>) ($W_{input} = H_{input}$). Sử dụng squere images cho phép chúng ta tận dụng các lợi ích của các thư viện tối ưu trong đại số tuyến tính. Kích thước
                    thường hay sử dụng là: 32x32, 64x64, 96x96, 224x224, 227x227, 229x229.</p>
                <ul>
                    <li><em><strong>Rule 2</strong></em></li>
                </ul>
                <p>Thứ 2, sau khi đi qua CONV layer đầu tiên, kích thước của images nên có thể chia hết cho 2. Điều này, cho phép POOL layer tiếp sau đó hoạt động theo cách hiệu quả hơn. Để áp dụng rule này, có thể điêu chỉnh kích thước của filters và stride.
                    Nói chung, CONV layers nên có kích thước nhỏ (<em>3x3 hoặc 5x5</em>). <code>Tiny filter</code> (<em>1x1</em>) có thể được sử dụng để học các <code>local features</code>, nhưng chỉ nên áp dụng trong các kiến trúc hiện đại và phức tạp.
                    Kích thước lớn hơn của filters (<em>7x7 hoặc 11x11</em>) cũng có thể xuất hiện ở CONV layer đầu tiên trong kiế trúc để giảm nhanh kích thước không gian của input volumn có kích thước &gt; 200x200 pixels. Nhấn mạnh là chỉ áp dung filers
                    có kích thước lớn ở CONV layer đầu tiên, ngược lại, input volumn sẽ giảm rất nhanh làm mất mát các features quan trọng.</p>
                <ul>
                    <li>
                        <p><em><strong>Rule 3</strong></em> Stride của CONV, S = 1 cũng nên được sử dụng cho các CONV layers đối với các input volumns có kích thước trung bình nhỏ (<em>&lt; 200x200 pixels</em>). Sử dụng S = 2 cho các input volumns có kích
                            thước lớn hơn, nhưng cũng chỉ nên áp dụng ở CONV layer đầu tiên. Khi S = 1 thì CONV layers làm nhiệm vụ học các features của images, trong khi POOL layers chịu trách nhiệm giảm kích thước input volumns. Tuy nhiên, nhắc lại
                            lần nữa rằng trong các kiến trúc CNN tiên tiến, POOL layers đang dần dần được thay thể bởi CONV layers với S &gt;= 2.</p>
                    </li>
                    <li>
                        <p><em><strong>Rule 4</strong></em> Cá nhân mình thường áp dụng <em>zero-padding</em> trong CONV layer để đảm bảo kich thước của input volumns không đổi khi đi qua CONV layer và sử dụng POOL layer để giảm kích thước input volumn.
                            Thực nghiệm của mình cho thấy <code>classification accuracy</code> thường cao hơn khi sử dụng rule này. Khi làm viêc với Keras framework, bạn có thể làm điều này một cách dễ dàng bằng cách setting <code>padding=same</code>                            khi tạo CONV layer. Bạn chỉ nên sử thay POOL layer bằng CONV layer khi đã thành thạo ở mức chuyên gia trong việc thiết kế kiến trúc của CNN.</p>
                    </li>
                    <li>
                        <p><em><strong>Rule 5</strong></em></p>
                    </li>
                </ul>
                <p>Đối với POOL layer, kích thước thông thường của nó trong kiến trúc CNN là 2x2, cộng với stride S = 2. Kích thước 3x3 cũng có thể sử dụng ở các layers đầu trong CNN để giảm nhanh kích thước của input volumn. Kích thước &gt; 3x3 chưa từng
                    thấy xuất hiện trong bất cứ mạng CNN nào từ trước đến giờ.</p>
                <ul>
                    <li><em><strong>Rule 6</strong></em></li>
                </ul>
                <p>Về phần Batch Normalization, như trong bài trước đã đề cập, mặc dù nó làm tăng lên đáng kể thời gian training, nhưng chúng ta vẫn nên sử dụng nó trong hầu hết các trường hợp vì những lợi ích mà nó mang lại. BN layer được đặt sau ACT layer
                    như trong các ví dụ sau:</p>
                <ul>
                    <li>
                        <p><strong>INPUT =&gt; CONV =&gt; RELU =&gt; BN =&gt; FC</strong></p>
                    </li>
                    <li>
                        <p><strong>INPUT =&gt; [CONV =&gt; RELU =&gt; BN =&gt; POOL]x2 =&gt; FC =&gt; RELU =&gt; BN =&gt; FC</strong></p>
                    </li>
                    <li>
                        <p><strong>INPUT =&gt; [[CONV =&gt; RELU =&gt; BN]x2 =&gt; POOL]x3 =&gt; [FC =&gt; RELU =&gt; BN]x2 =&gt; FC</strong></p>
                    </li>
                    <li>
                        <p><em><strong>Rule 7</strong></em></p>
                    </li>
                </ul>
                <p>Droput (DO) được đặt giữa các FC layers với xác suất ngắt kết nối các nodes là 50%. Nó cũng được khuyên sử dụng DO trong mọi kiến trúc CNN của bạn. Cá nhân mình, đôi khi cũng đặt DO ở giữa CONV và POOL layers, và điều này đôi khi cũng
                    tỏ ra hiệu quả trong việc giảm bớt Overfitting. Bạn có thể thử-sai trong các bài toán của bạn.</p>
                <p>Ok, đó là 7 rules mình muốn giới thiệu đến các bạn. Bằng viêc ghi nhớ những rules này, bạn sẽ bớt <em>đau đầu</em> hơn khi xây dựng kiến trúc CNN của riêng mình. Một khi bạn đã trở thành chuyên gian xây dựng mạng CNN theo cách <em>truyền thống</em>                    như thế này, hãy thử bỏ qua <code>max pooling</code>, chỉ sử dụng CONV layer để giảm kích thước không gian của input volumns và sử dụng <code>average pooling</code> thay thế cho FC layer để giảm độ phức tạp tính toán của CNN. Mình
                    sẽ đề cập chi tiết hơn những kỹ thuật <em>advances</em> này trong các bài viết về sau.</p>
                <p><strong>4. Tổng kết</strong></p>
                <p>Vậy là mình đã kết thúc 3 bài viết về CNN. Hi vọng với những kiến thức chia sẻ ở đây sẽ giúp ích được cho các bạn, đặc biệt là các patterns và rules ở bài số 3 này. Các bạn có thể áp dụng luôn vào trong bài toán của mình và kiểm tra sự
                    khác biệt.</p>
                <p><strong>Tham khảo</strong></p>
                <ul>
                    <li><a href="https://www.pyimagesearch.com/">Pyimagesearch</a></li>
                    <li><a href="https://d2l.ai/chapter_convolutional-neural-networks/index.html">Dive into Deep Learning</a></li>
                    <li><a href="https://cs231n.github.io/convolutional-networks/">CS231</a></li>
                </ul>

            </div>
            <div class="info post_meta">
                <time datetime=2020-11-05T00:00:00Z class="date">Thursday, November 5, 2020</time>

                <ul class="tags">

                    <li> <a href="https://tiensu.github.io/tags/ai">AI</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/deep-learning">Deep Learning</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/neural-network">Neural Network</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/cnn">CNN</a> </li>

                </ul>


            </div>
            <div class="clearfix"></div>
        </article>

        <div class="other_posts">

            <a href="https://tiensu.github.io/posts/21_convolutional_neural_network_2/" class="prev">Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 2</a>


            <a href="https://tiensu.github.io/posts/23_for_book_lover/" class="next">Dành cho người yêu sách</a>

        </div>
        <aside id="comments">
        </aside>


    </section>

    <a id="back_to_top" title="Go To Top" href="#">
        <span>
    <svg viewBox="0 0 24 24">
      <path fill="none" d="M0 0h24v24H0z"></path>
      <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"></path>
    </svg>
  </span>
    </a>

    <footer id="footer">
        <p>
            <span>&copy; 2020 <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a> </span>
            <span>Built with <a rel="nofollow" target="_blank" href="https://gohugo.io">Hugo</a></span>
            <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/wayjam/hugo-theme-mixedpaper">WayJam</a></span>
        </p>
        <script src="https://tiensu.github.io/js/main.min.8b182175f5874aeed0acc0979345c98d4bde22208ec4f36cc1d6e3102acb4b10.js" integrity="sha256-ixghdfWHSu7QrMCXk0XJjUveIiCOxPNswdbjECrLSxA=" crossorigin="anonymous" async></script>
    </footer>

</body>

</html>