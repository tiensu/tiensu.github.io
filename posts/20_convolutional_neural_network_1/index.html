<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="format-detection" content="telephone=no" />

    <title>
        Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 1 | ML in Practical
    </title>


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#ffffff" />


    <link rel="stylesheet" href="https://unpkg.com/modern-normalize@0.6.0/modern-normalize.css" />





    <link rel="stylesheet" href="https://tiensu.github.io/style.min.388cbd0ce358245ec0dfcee3b8889b3cc50e2bb8a5b2bcd40f8bd092ebefb81a.css" integrity="sha256-OIy9DONYJF7A387juIibPMUOK7ilsrzUD4vQkuvvuBo=" />




    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function(i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'UA-180180568-1', 'auto');
            ga('set', 'anonymizeIp', true);
            ga('send', 'pageview');
        }
    </script>


</head>

<body>
    <header id="header">

        <script type="application/javascript">
            var doNotTrack = false;
            if (!doNotTrack) {
                (function(i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r;
                    i[r] = i[r] || function() {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date();
                    a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                    a.async = 1;
                    a.src = g;
                    m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
                ga('create', 'UA-180180568-1', 'auto');
                ga('set', 'anonymizeIp', true);
                ga('send', 'pageview');
            }
        </script>

        <div class="header_container">
            <h1 class="sitetitle">
                <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a>
            </h1>
            <nav class="navbar">
                <ul>
                    <li><a href="https://tiensu.github.io/">Home</a></li>

                    <li>
                        <a href="/about/">

                            <span>About</span>
                        </a>
                    </li>

                    <li>
                        <a href="/tags/">

                            <span>Tags</span>
                        </a>
                    </li>

                    <li>
                        <a href="/archives/">

                            <span>Archives</span>
                        </a>
                    </li>

                    <li class="hide-sm"><a href="https://tiensu.github.io/index.xml" type="application/rss+xml">RSS</a></li>
                </ul>
            </nav>
        </div>
        <script>
            MathJax = {
                tex: {
                    inlineMath: [
                        ['$', '$'],
                        ['\\(', '\\)']
                    ],
                    displayMath: [
                        ['$$', '$$'],
                        ['\\[', '\\]']
                    ],
                    processEscapes: true,
                    processEnvironments: true
                },
                options: {
                    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            };

            window.addEventListener('load', (event) => {
                document.querySelectorAll("mjx-container").forEach(function(x) {
                    x.parentElement.classList += 'has-jax'
                })
            });
        </script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    </header>


    <section id="main">
        <article class="post content">
            <h2 class="title">Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 1</h2>
            <div class="post_content">
                <p>Sau khi đã tìm hiểu cơ bản về Neural Network, chúng ta sẽ đi tìm hiểu về CNN. CNN là một dạng kiến trúc Neural Network đóng vai trò vô cùng quan trọng trong Deep Learning.</p>
                <p>Trong <code>Feedfoward Neural Network</code>, mỗi neural trong một layer được kết nối đến tất cả các nodes của layer tiếp theo. Ta gọi điều này là <code>Fully Connected (FC)</code> layer. Tuy nhiên, trong CNNs, FC layers chỉ được sử dụng
                    ở 1 vài layers cuối. Các layers còn lại được gọi là <code>convolutional</code> layers.</p>
                <p>Một hàm kích hoạt (<em>activation function</em>) (thường là ReLU) được áp dụng tới output của các <code>convolutional</code> layers. Kết hợp với các dạng layers khác nhau để giảm kích thước của input. Các FC layers ở cuối có nhiệm vụ phân
                    loại output thành các classes khác nhau.</p>
                <p>Mỗi layer trong CNN áp dụng một tập các bộ lọc (<em>filters</em>) (có thể lên đến hàng trăm hoặc hàng nghìn), kết hợp kết quả lại, cho qua layer tiếp theo. Trong suốt quá trình training, giá trị của các filters được cập nhật (<em>tương tự như trọng số weight trong Neural Network</em>).</p>
                <p>Trong lĩnh vực xử lý ảnh, CNN có thể học để:</p>
                <ul>
                    <li>Phát hiện biên (<em>edges</em>) từ <code>raw pixel data</code> ở layer đầu tiên.</li>
                    <li>Sử dụng edges đã phát hiện để phát hiện hình dạng (<em>shapes</em>) đối tượng ở layer thứ 2.</li>
                    <li>Sử dụng shapes để phát hiện <code>heigher-level features</code> trong các layers tiếp theo.</li>
                </ul>
                <p><strong>1. Hiểu rõ về Convolutions</strong></p>
                <p>Chúng ta sẽ cùng nhau trả lời một số câu hỏi sau:</p>
                <ul>
                    <li>Convolutions là gì?</li>
                    <li>Chúng lamf được những việc gì?</li>
                    <li>Tại sao lại sử dụng chúng?</li>
                    <li>Áp dụng chúng vào xử lý ảnh như thế nào?</li>
                </ul>
                <p>Từ <code>convolution</code>, dịch sang tiếng việt là <code>tích chập</code>, nghe có vẻ phức tạp. Bạn chắc chắn đã nghe đến từ này nếu bạn học qua môn <code>Xử lý tín hiệu sô</code>. Tuy nhiên, <code>convolution</code> trong lĩnh vực xử
                    lý lý ảnh hơi khác một chút. Không phải khi có Deep Learning, chúng ta mới sử dụng <code>convolution</code>, các phương pháp xử lý ảnh truyền thống đều sử dụng <code>convolution</code>: Edges detection, Sharpen images, Blurring and
                    Smoothing images, &hellip; Vì thế mới nói, <code>convolution</code> là xương sống của xử lý ảnh. Hiểu rõ <code>convolution</code> là điều kiện tiên quyết để bước chân vào lĩnh vựa xử lý ảnh (theo cả phương pháp truyền thống và sử dụng
                    Deep Learning).</p>
                <p>Nghe thì có vẻ &ldquo;đao to búa lớn&rdquo; vậy, nhưng thực sự không phải vậy. <code>Convolution</code> đơn giản chỉ là tổng của các tích đôi một của từng phần tử tron 2 ma trận. Chia nhỏ các bước ra cho dễ hiểu:</p>
                <ul>
                    <li>Lấy 2 ma trận có cùng kích thước</li>
                    <li>Nhân 2 ma trận đôi một (<em>element-by-element</em>) (không phải phép nhân ma trận trong đại số tuyến tính).</li>
                    <li>Cộng kết quả của các tích lại.</li>
                </ul>
                <p>Yup, đó là <code>convolution</code>.</p>
                <p><em><strong>1.1 Kernel</strong></em></p>
                <p>Một image là một ma trận nhiều chiều. Thường là 3 chiều (w, h, c) với width là số cột, height là số hàng và depth là số kênh màu. &ldquo;Image matrix&rdquo; thường được gọi với cái tên &ldquo;big matrix&rdquo;. Một ma trận khác gọi là
                    <code>kernel</code> (hoặc &ldquo;convolution matrix&rdquo;, &ldquo;tiny matrix&rdquo;, filter) đặt bên trên &ldquo;big matrix&rdquo;, trượt từ trái sang phải, từ trên xuống dưới. Trong quá trình di chuyển, các phép toán (convolution,
                    &hellip;) được áp dụng đối với 2 ma trận đó. Sử dụng các kernel khác nhau, ta có thể đạt được các mục đích mong muốn: Blurring (<em>average smoothing, Gaussian smoothing, &hellip;</em>), Edge detection (<em>Laplacian, Sobel, ..</em>.),
                    &hellip;
                </p>
                <p>Để hiểu rõ hơn, chúng ta sẽ làm thử 1 ví dụ cụ thể.</p>
                <p>Giả sử có &ldquo;image matrix&rdquo; kernel như sau:</p>
                <p>

                    <div style="text-align:center">
                        <img src="/kernel.png">
                    </div>




                    <div style="text-align:center">
                        <img src="/image_matrix.png">
                    </div>

                </p>
                <p>Theo lý thuyết bên trên, kernel sẽ được trượt qua &ldquo;image matrix&rdquo; từ trái qua phải, từ trên xuống dưới. Số bước trượt thường là 1 hoặc 2. Tại bước, sau khi trượt xong, ta sẽ dừng lại, thực hiện phép <code>convolution</code>                    giữa kernel và phần &ldquo;image matrix&rdquo; bị che bởi kernel. Giá trị ouput được lưu trong ma trận kết quả tại vị trí trung tâm của kernel tại bước đó.</p>
                <p>Chi tiết các bước:</p>
                <ul>
                    <li>Chọn tọa độ ($x,y$) từ &ldquo;image matrix&rdquo;.</li>
                    <li>Đặt <code>center</code> của kernel tại ($x,y$).</li>
                    <li>Thực hiện <code>convolution</code> giữa kernel và phần &ldquo;image matrix&rdquo; bị che phủ bởi kernel.</li>
                    <li>Lưu kết quả tại ($x,y$) của ma trận kết quả.</li>
                </ul>
                <p>Ví dụ, với $(x,y) = (3,3)$:


                    <div style="text-align:center">
                        <img src="/convolution_ex.png">
                    </div>




                    <div style="text-align:center">
                        <img src="/convolution_ex_2.png">
                    </div>

                </p>
                <p>Sau khi tính toán xong, ta sẽ gán giá trị 132 cho pixel tại vị trí (3,3) của ma trận kết quả. $O_{i,j}$ = 132.</p>
                <p><em><strong>1.2 Implement Convolutions bằng python.</strong></em></p>
                <p>Giờ hãy bắt tay vào code thôi. Việc thực hiện <code>convolution</code> bằng code sẽ giúp bạn hiểu sâu sắc hơn cách áp dụng <code>convolution</code> trong xử lý ảnh.</p>
                <p>Tạo file convolutions.py và code như sau:</p>
                <div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># USAGE</span>
<span class="c1"># python convolutions.py --image mai-ngoc.jpg</span>

<span class="c1"># import the necessary packages</span>
<span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
	<span class="c1"># grab the spatial dimensions of the image and kernel</span>
	<span class="p">(</span><span class="n">iH</span><span class="p">,</span> <span class="n">iW</span><span class="p">)</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">(</span><span class="n">kH</span><span class="p">,</span> <span class="n">kW</span><span class="p">)</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

	<span class="c1"># allocate memory for the output image, taking care to &#34;pad&#34; the orders of the input image so the spatial size (i.e., width and height) are not reduced</span>
	<span class="n">pad</span> <span class="o">=</span> <span class="p">(</span><span class="n">kW</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span>
		<span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">)</span>
	<span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iH</span><span class="p">,</span> <span class="n">iW</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;float&#34;</span><span class="p">)</span>

	<span class="c1"># loop over the input image, &#34;sliding&#34; the kernel across each (x, y)-coordinate from left-to-right and top-to-bottom</span>
	<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">iH</span> <span class="o">+</span> <span class="n">pad</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">iW</span> <span class="o">+</span> <span class="n">pad</span><span class="p">):</span>
			<span class="c1"># extract the ROI of the image by extracting the *center* region of the current (x, y)-coordinates dimensions</span>
			<span class="n">roi</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">y</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

			<span class="c1"># perform the actual convolution by taking the element-wise multiplication between the ROI and the kernel, the summing the matrix</span>
			<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">roi</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

			<span class="c1"># store the convolved value in the output (x, y)- coordinate of the output image</span>
			<span class="n">output</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

	<span class="c1"># rescale the output image to be in the range [0, 255]</span>
	<span class="n">output</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
	<span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">output</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&#34;uint8&#34;</span><span class="p">)</span>

	<span class="c1"># return the output image</span>
	<span class="k">return</span> <span class="n">output</span>

<span class="c1"># construct the argument parse and parse the arguments</span>
<span class="n">ap</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">ap</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&#34;-i&#34;</span><span class="p">,</span> <span class="s2">&#34;--image&#34;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
	<span class="n">help</span><span class="o">=</span><span class="s2">&#34;path to the input image&#34;</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">ap</span><span class="o">.</span><span class="n">parse_args</span><span class="p">())</span>

<span class="c1"># construct average blurring kernels used to smooth an image</span>
<span class="n">smallBlur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;float&#34;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">largeBlur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;float&#34;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">21</span> <span class="o">*</span> <span class="mi">21</span><span class="p">))</span>

<span class="c1"># construct a sharpening filter</span>
<span class="n">sharpen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;int&#34;</span><span class="p">)</span>

<span class="c1"># construct the Laplacian kernel used to detect edge-like regions of an image</span>
<span class="n">laplacian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;int&#34;</span><span class="p">)</span>

<span class="c1"># construct the Sobel x-axis kernel</span>
<span class="n">sobelX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;int&#34;</span><span class="p">)</span>

<span class="c1"># construct the Sobel y-axis kernel</span>
<span class="n">sobelY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;int&#34;</span><span class="p">)</span>

<span class="c1"># construct an emboss kernel</span>
<span class="n">emboss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
	<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&#34;int&#34;</span><span class="p">)</span>

<span class="c1"># construct the kernel bank, a list of kernels we&#39;re going to apply using both our custom `convole` function and OpenCV&#39;s `filter2D` function</span>
<span class="n">kernelBank</span> <span class="o">=</span> <span class="p">(</span>
	<span class="p">(</span><span class="s2">&#34;small_blur&#34;</span><span class="p">,</span> <span class="n">smallBlur</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;large_blur&#34;</span><span class="p">,</span> <span class="n">largeBlur</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;sharpen&#34;</span><span class="p">,</span> <span class="n">sharpen</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;laplacian&#34;</span><span class="p">,</span> <span class="n">laplacian</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;sobel_x&#34;</span><span class="p">,</span> <span class="n">sobelX</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;sobel_y&#34;</span><span class="p">,</span> <span class="n">sobelY</span><span class="p">),</span>
	<span class="p">(</span><span class="s2">&#34;emboss&#34;</span><span class="p">,</span> <span class="n">emboss</span><span class="p">))</span>

<span class="c1"># load the input image and convert it to grayscale</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&#34;image&#34;</span><span class="p">])</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

<span class="c1"># loop over the kernels</span>
<span class="k">for</span> <span class="p">(</span><span class="n">kernelName</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kernelBank</span><span class="p">:</span>
	<span class="c1"># apply the kernel to the grayscale image using both our custom `convolve` function and OpenCV&#39;s `filter2D` function</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">&#34;[INFO] applying {} kernel&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kernelName</span><span class="p">))</span>
	<span class="n">convolveOutput</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
	<span class="n">opencvOutput</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">filter2D</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

	<span class="c1"># show the output images</span>
	<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&#34;Original&#34;</span><span class="p">,</span> <span class="n">gray</span><span class="p">)</span>
	<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&#34;{} - convole&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kernelName</span><span class="p">),</span> <span class="n">convolveOutput</span><span class="p">)</span>
	<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&#34;{} - opencv&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kernelName</span><span class="p">),</span> <span class="n">opencvOutput</span><span class="p">)</span>
	<span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</code></pre></div>
                <p>Kết quả:</p>


                <div style="text-align:center">
                    <img src="/convolution_result.png">
                    <p><strong>Từ trái sang phải</strong>: Ảnh gốc, ảnh áp dụng "average blur" sử dụng 7x7 kernel convolution, và ảnh áp dụng "average blur" sử dụng OpenCV’s cv2.filter2D.</p>
                </div>


                <p><em><strong>1.3 Vai trò của Convolutions trong Deep Learning</strong></em></p>
                <p>Như các bạn đã thấy từ phần trước, chúng ta phải tự định nghĩa (<em>manually hand-define</em>) các kernel cho mỗi nhiệm vụ xử lý ảnh khác nhau.</p>
                <p><strong>Liệu có cách nào &ldquo;tự động hóa&rdquo; việc này?</strong></p>
                <p>CNN chính là câu trả lời. Bằng cách sắp xếp nhiều lớp convolutions, kết hợp với &ldquo;activation function&rdquo;, pooling, backpropagation, &hellip; CNNs có khả năng học để cập nhật giá trị của kernel, từ đó trích xuất được các đặc trưng
                    của đối tượng trong ảnh.</p>
                <p>Trong bài tiếp theo, mình sẽ tìm hiểu kỹ hơn về các dạng layers khác nhau, sau đó sẽ đưa ra một số &ldquo;common layer stacking patterns&rdquo; được sử dụng rộng rãi trong lĩnh vực xử lý ảnh.</p>
                <p>Source code sử dụng trong bài này, các bạn có thể tham khảo tại github cá nhân của mình tại <a href="https://github.com/tiensu/Computer_Vision/tree/master/Deep_Learning/conv_with_python">github</a></p>
                <p><strong>Tham khảo</strong></p>
                <ul>
                    <li><a href="https://www.pyimagesearch.com/">Pyimagesearch</a></li>
                    <li><a href="https://d2l.ai/chapter_convolutional-neural-networks/index.html">Dive into Deep Learning</a></li>
                    <li><a href="https://cs231n.github.io/convolutional-networks/">CS231</a></li>
                </ul>

            </div>
            <div class="info post_meta">
                <time datetime=2020-10-27T00:00:00Z class="date">Tuesday, October 27, 2020</time>

                <ul class="tags">

                    <li> <a href="https://tiensu.github.io/tags/ai">AI</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/deep-learning">Deep Learning</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/neural-network">Neural Network</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/cnn">CNN</a> </li>

                </ul>


            </div>
            <div class="clearfix"></div>
        </article>

        <div class="other_posts">

            <a href="https://tiensu.github.io/posts/19_neural_network_fundamentals_2/" class="prev">Neural Network cơ bản (Phần 2)</a>


            <a href="https://tiensu.github.io/posts/21_convolutional_neural_network_2/" class="next">Mạng thần kinh tích chập (Convolutional Neural Network (CNN) - Phần 2</a>

        </div>
        <aside id="comments">
        </aside>


    </section>

    <a id="back_to_top" title="Go To Top" href="#">
        <span>
    <svg viewBox="0 0 24 24">
      <path fill="none" d="M0 0h24v24H0z"></path>
      <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"></path>
    </svg>
  </span>
    </a>

    <footer id="footer">
        <p>
            <span>&copy; 2020 <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a> </span>
            <span>Built with <a rel="nofollow" target="_blank" href="https://gohugo.io">Hugo</a></span>
            <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/wayjam/hugo-theme-mixedpaper">WayJam</a></span>
        </p>
        <script src="https://tiensu.github.io/js/main.min.8b182175f5874aeed0acc0979345c98d4bde22208ec4f36cc1d6e3102acb4b10.js" integrity="sha256-ixghdfWHSu7QrMCXk0XJjUveIiCOxPNswdbjECrLSxA=" crossorigin="anonymous" async></script>
    </footer>

</body>

</html>