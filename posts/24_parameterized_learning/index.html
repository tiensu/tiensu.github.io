<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="format-detection" content="telephone=no" />

    <title>
        Parameterized Learning | ML in Practical
    </title>


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#ffffff" />


    <link rel="stylesheet" href="https://unpkg.com/modern-normalize@0.6.0/modern-normalize.css" />





    <link rel="stylesheet" href="https://tiensu.github.io/style.min.388cbd0ce358245ec0dfcee3b8889b3cc50e2bb8a5b2bcd40f8bd092ebefb81a.css" integrity="sha256-OIy9DONYJF7A387juIibPMUOK7ilsrzUD4vQkuvvuBo=" />




    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function(i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'UA-180180568-1', 'auto');
            ga('set', 'anonymizeIp', true);
            ga('send', 'pageview');
        }
    </script>


</head>

<body>
    <header id="header">

        <script type="application/javascript">
            var doNotTrack = false;
            if (!doNotTrack) {
                (function(i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r;
                    i[r] = i[r] || function() {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date();
                    a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                    a.async = 1;
                    a.src = g;
                    m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
                ga('create', 'UA-180180568-1', 'auto');
                ga('set', 'anonymizeIp', true);
                ga('send', 'pageview');
            }
        </script>

        <div class="header_container">
            <h1 class="sitetitle">
                <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a>
            </h1>
            <nav class="navbar">
                <ul>
                    <li><a href="https://tiensu.github.io/">Home</a></li>

                    <li>
                        <a href="/about/">

                            <span>About</span>
                        </a>
                    </li>

                    <li>
                        <a href="/tags/">

                            <span>Tags</span>
                        </a>
                    </li>

                    <li>
                        <a href="/archives/">

                            <span>Archives</span>
                        </a>
                    </li>

                    <li class="hide-sm"><a href="https://tiensu.github.io/index.xml" type="application/rss+xml">RSS</a></li>
                </ul>
            </nav>
        </div>
        <script>
            MathJax = {
                tex: {
                    inlineMath: [
                        ['$', '$'],
                        ['\\(', '\\)']
                    ],
                    displayMath: [
                        ['$$', '$$'],
                        ['\\[', '\\]']
                    ],
                    processEscapes: true,
                    processEnvironments: true
                },
                options: {
                    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            };

            window.addEventListener('load', (event) => {
                document.querySelectorAll("mjx-container").forEach(function(x) {
                    x.parentElement.classList += 'has-jax'
                })
            });
        </script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    </header>


    <section id="main">
        <article class="post content">
            <h2 class="title">Parameterized Learning</h2>
            <div class="post_content">
                <p>Bạn có biết thuật toán kNN - một trong những thuật toán đơn giản nhất của ML? Về bản chất, nó không &ldquo;học&rdquo; bất cứ điều gì từ dữ liệu mà chỉ đơn giản là lưu dữ liệu bên trong model, và tại thời điểm dự đoán, nó so sánh dữ liệu
                    cần dự đoán với dữ liệu trong tập training. Rõ ràng với cách làm việc như vậy thì ưu điểm lớn nhất của kNN là không mất thời gian training model. Không không cần quá quan tâm về độ chính xác thì ưu điểm này chính là lý do mà kNN vẫn
                    còn được sử dụng trong một số trường hợp. Hạn chế của kNN chỉ xuất hiên khi gặp bài toán mà sử dụng lượng dữ liệu lớn. Lúc này thời gian dự đoán của kNN sẽ rất lâu, và đôi khi không thể sử dụng được trong thực tế.</p>
                <p>Một các tiếp cận khác của ML model mà ở đó nó có thể học được các patterns từ dữ liệu trong suốt quá trình training. Sau đó, ở giai đoạn dự đoán, ML model đó có thể thực hiện rất nhanh chóng để đưa ra kết quả. Dạng này của ML được gọi
                    là <code>parameterized learning</code>.</p>
                <p>Dưới đây là định nghĩa chính thống từ tác giả:</p>
                <p><em>“A learning model that summarizes data with a set of parameters of fixed size
(independent of the number of training examples) is called a parametric model. No
matter how much data you throw at the parametric model, it won’t change its mind
about how many parameters it needs.”</em> – Russell and Norvig (2009).</p>
                <p>Có thể nói <code>parameterized learning</code> là nền tằng của các thuật toán ML và DL hiện đại ngày nay. Trong bài này, chúng ta sẽ cùng xem xét chi tiết một vài khía cạnh về nó!</p>
                <p><strong>1. Bốn thành phần cơ bản của Parameterized Learning</strong></p>
                <p>Hiểu một cách đơn giản, <code>parameterization</code> là quá trình định nghĩa các tham số cần thiết cho một model. Nó bao gồm 4 thành phần: <em>Data, Score Function, Loss Function, Weight-Bias</em>.</p>
                <p><em><strong>1.1 Data</strong></em></p>
                <p>Data ở đây chính là input data đưa vào để model học, nó bao gồm <code>Data Points</code> (<em>VD: Các raw pixel của bức anh, các trích xuất đặc trưng của đối tượng, &hellip;</em>) và nhãn kết hợp với Data Points.</p>
                <p>Data thường được biểu diễn dưới dạng ma trận (<em>gọi là <strong>desing matrix</strong></em>). Mỗi hàng của matrix đại diện cho một Data Point, trong khi mỗi cột của nó thể hiện moojtoj feature.</p>
                <p>Ví dụ, xem xét một dataset gồm 1000 bức ảnh màu, mỗi ảnh có kích thước 96x96x3 pixels. Design Matrix cho dataset này sẽ là: $X \subseteq R^{100 \times (32 \times 32 \times 3)}$, với $X_i$ là ảnh thức $i$ trong $R$. Cùng với Design Matrix,
                    ta cũng định nghĩa vector $y$ mà $y_i$ là nhãn cho ảnh thứ $i$ trong dataset.</p>
                <p><em><strong>1.2 Scoring Function</strong></em></p>
                <p>Hàm này chấp nhận một input data, sau đó ánh xạ nó sang nhãn tương ứng.</p>
                <p><strong>INPUT_IMAGES =&gt; F(INPUT_IMAGES) =&gt; OUTPUT_CLASS_LABELS</strong></p>
                <p><em><strong>1.3 Loss Function</strong></em></p>
                <p>Loss Function đánh giá mức độ phù hợp giữa nhãn dự đoán (<em>predicted label</em>) và nhãn thực tế (<em>ground-truth label</em>). Giá trị của hàm này tỉ lệ nghịch với mức độ phù hợp hay độ chính xác của model. Mục tiêu của chúng ta khi
                    training AI model là tối thiểu hóa loss funtion.</p>
                <p><em><strong>1.4 Weights and Biases</strong></em></p>
                <p>Weight Matrix (<strong>$W$</strong>) và vector bias ($b$) là những cái được điều chỉnh, cập nhật trong quá trình training AI model, dựa trên output của Score Function và Loss Function. Mục đích cuối cùng cũng vẫn là tăng độ chính xác phân
                    loại của AI model.</p>
                <p>Tiếp theo, chúng ta sẽ sử dụng 4 thành phần này để xây dựng một <code>linear classification</code>.</p>
                <p><strong>2. Ưu điểm của Parameterized Learning</strong></p>
                <p>Có 2 ưu điểm chính để sử dụng Parameterized Learning:</p>
                <ul>
                    <li>Một khi đã hoàn thành viêc training model, ta có thể bỏ qua input data, chỉ giữ lại Weight Matrix <strong>$W$</strong> và bias vector $b$. Điều này giúp giảm đáng kể kích thước của model.</li>
                    <li>Tốc độ của việc phân loại sử dụng model đã trained nhanh hơn rất nhiều so với thuật toán kNN. Ta chỉ cần nhân 2 matrix <strong>$W$</strong> và $x_i$, rồi cộng với $b$.</li>
                </ul>
                <p><strong>3. Linear Classification</strong></p>
                <p>Phần này, chúng ta sẽ đi sâu hơn 1 chút về toán, tìm hiểu cách mà <code>parameterized learning</code> áp dụng vào machine learning.</p>
                <p>Giả sử chúng ta có một bộ dataset gồm $N$ ảnh kích thước ($W_{input}, H_{input}, 3$), ký hiệu là $x_i, i = 1, 2, &hellip;, N$. Mỗi $x_i$ có một nhãn tương ứng $y_j, j = 1, 2, &hellip;, K$. Nói một cách khác, chúng ta có $N$ Data Points,
                    mỗi Data Point có $D = (W_{input} \times H_{input}\times3)$ chiều, và được chia thành $K$ nhóm phân biệt.</p>
                <p>Ta định nghĩa Score Function thông qua một hàm tuyến tính đơn giản như sau:</p>


                <div style="text-align:center">$f(x_i, W, b) = Wx_i + b$</div>


                <p>Giả sử mỗi $x_i$ được đại diện bởi một vector cột với kích thước $[D\times1]$ (đối với images, ta duỗi thẳng theo cả 3 chiều thành $D = (W_{input} \times H_{input}\times3)$ giá trị nguyên của các pixcels). Weight Matrix $W$ sẽ có kích
                    thước $[K \times D]$ và bias $b$ sẽ có kích thước $[K \times 1]$. Vector bias cho phép ta dịch chuyển Score Function trên toàn bộ trên đồ thị, đóng vai trò quan trọng đối với sự thành công của AI model.</p>
                <p>Ví dụ cụ thể đối một dataset có 3000 bức ảnh, mỗi ảnh có kích thước $[32 \times 32 \times 3]$ và được phân chia vào 1 trong 3 nhóm. Khi đó mỗi $x_i$ được đại diện bởi D = 32<em>32</em>3 = 3072 pixels và có kích thước $[3072 \times 1]$.
                    Weight Matrix <strong>$W$</strong> có kích thước $[3 \times 3072]$ và bias vector $b$ có kích thước $[3 \times 1]$.</p>
                <p>Hình dưới minh họa <code>linear classification Score Function</code> $f$. Bên trái là ảnh đầu vào kích thuớc $[32 \times 32 \times 3]$ được &ldquo;duỗi thẳng&rdquo; thành 3072 pixcels (bằng cách reshape 3D array thành 1D list).</p>


                <div style="text-align:center">
                    <img src="/parameterized_learning.png" width="800" height="400">
                </div>


                <p>Weight Matrix <strong>$W$</strong> chứa 3 hàng (mỗi hàng tương ứng với 1 nhãn) và 3072 cột (mỗi cột tương ứng với 1 pixel của ảnh). Sau khi nhân 2 matrix <strong>$W$</strong> và $x_i$, ta cộng thêm bias vector $b$ sẽ thu được output của
                    Score Function, như bên trái của hình trên. Có 3 giá trị tương ứng với 3 nhãn: Cat, Dog và Panda.</p>
                <p><strong>4. Thực hành Linear Classification với Python</strong></p>
                <p>Chúng ta đã có hình dung cơ bản về lý thuyết của Parameterized Learning, giờ ta sẽ bắt tay vào thực hành code để có thể hiểu hơn.</p>
                <p>Mục đích của phần này không phải hướng dẫn việc training model, chỉ đơn giản là cài đạt Score Function bằng python mà thôi. Khi training model thì <strong>$W$</strong> và $b$ sẽ được khởi tạo và cập nhật dần dần trong quá trình training,
                    còn ở đây, chúng chỉ được khởi tạo 1 lần và sử dụng luôn để tính output của Score Function.</p>
                <p>Mục tiêu của ta ở đây là nhận diện xem ảnh dưới đây là con gì trong số 3 con vật: Cat, Dog và Panda.</p>


                <div style="text-align:center">
                    <img src="/dog.png" width="500">
                </div>


                <p>Chúng ta sẽ code như sau (<em>xem giải thích trong comment code</em>):</p>
                <div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># import the necessary packages</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="c1"># initialize the class labels and set the seed of the pseudorandom number generator so we can reproduce our results</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;dog&#34;</span><span class="p">,</span> <span class="s2">&#34;cat&#34;</span><span class="p">,</span> <span class="s2">&#34;panda&#34;</span><span class="p">]</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># randomly initialize our Weight Matrix and bias vector -- in a *real* training and classification task, these parameters would be </span>
<span class="c1"># *learned* by our model, but for the sake of this example, let&#39;s use random values</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3072</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># load our example image, resize it, and then flatten it into our &#34;feature vector&#34; representation</span>
<span class="n">orig</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">&#34;dog.png&#34;</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># compute the output scores by taking the dot product between the Weight Matrix and image pixels, followed by adding in the bias</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># loop over the scores + labels and display them</span>

</code></pre></div>
                <p>Chạy code trên ta thu được kết quả trên terminal:</p>
                <pre><code>[INFO] dog: 8058.57
[INFO] cat: -2926.35
[INFO] panda: 3531.41
</code></pre>
                <p>và ảnh hiển thị:


                    <div style="text-align:center">
                        <img src="/dog_2.png" width="500">
                    </div>

                </p>
                <p>Nhắc lại lần nữa là khi thực hiện bài toán AI trong thực tế từ đầu, chúng ta cần phải cập nhật <strong>$W$</strong> và $b$ thông qua các thuật toán tối ưu. Thuật toán tối ưu kinh điển là <em>Gradient Descent</em> sẽ được tìm hiểu chi tiết
                    trong bài viết tiếp theo.</p>
                <p><strong>5. Loss Function</strong></p>
                <p><em><strong>5.1 Loss Function là gì?</strong></em></p>
                <p><code>Loss Function</code>, tên tiếng việt là <code>hàm mất mát</code>, thể hiện sai số giữa giá trị dự đoán của model và giá trị thực tế. Sai số càng nhỏ thì model dự đoán càng chính xác và ngược lại.</p>
                <p>Mục tiêu của việc training model là cập nhật <strong>$W$</strong> và $b$ để tối thiểu hóa giá trị của Loss Function, qua đó nâng cao độ chính xác của model.</p>
                <p>Một cách lý tưởng, Loss Function nên giảm dần theo thời gian trong quá trình training như hình bên dưới:</p>


                <div style="text-align:center">
                    <img src="/loss.png" width="500">
                </div>


                <p><em><strong>5.2 Multi-class SVM Loss</strong></em></p>
                <p>Multi-class SVM Loss là sự mở rộng của Linear SVM, xuất hiện trong bài toán khi cần phân biệt nhiều labels (<em>&gt; 2</em>). Nó sử dụng Score Function $f$ để ánh xạ mỗi Data Point thành các Scores cho mỗi nhãn.</p>
                <p>Score Function $f$ có dạng như sau:</p>


                <div style="text-align:center">$f(x_i, W, b) = Wx_i + b$</div>


                <p>Để phán định một model là &ldquo;good&rdquo; hay &ldquo;bad&rdquo;, ta cần thêm một Loss Function.</p>
                <p>Ta đã biết khi tạo ra một ML model, chúng ta có Design Matrix $X$, ở đó, mỗi hàng của $X$ là một Data Point ($x_i$) mà chúng ta muốn phân loại (<em>tìm nhãn cho Data Point đó</em>). Ground-truth Label cho $x_i$, ký hiệu $y_i$ là vector
                    mà chúng ta hi vọng Score Function sẽ dự đoán đúng.</p>
                <p>Viết lại Score Function như sau:</p>


                <div style="text-align:center">$s = f(x_i, W)$</div>


                <p>Predicted Score của class <em>j-th</em> tại <em>i-th</em> Data Point sẽ là:</p>


                <div style="text-align:center">$s_j = f(x_i, W)_j$</div>


                <p>Ta định nghĩa Hinge Loss Function như sau:</p>


                <div style="text-align:center">$L_i = \sum_{j \neq y_i} max(0, s_j - s_{y_i} +1)$</div>


                <p>Hàm này tính tổng các sai số giữa các Score của nhãn dự đoán so với nhãn thực tế. Ở đây, sử dụng hàm $max()$ để bỏ qua những giá trị âm của độ lệch. $x_i$ được dự đoán chính xác khi $L_i$ = 0.</p>
                <p>Áp dụng cho toàn bộ tập training, ta lấy trung bình của mỗi $L_i$:</p>


                <div style="text-align:center">$L = \frac{1}{N} \sum_{i=1}^N L_i$</div>


                <p>Một dạng khác của Loss Function mà ta có thể gặp trong một số tài liệu là <strong>Squared Hinge Loss</strong>:</p>


                <div style="text-align:center">$L_i = \sum_{j \neq y_i} max(0, s_j - s_{y_i} + 1)^2$</div>


                <p>Dạng này sẽ &ldquo;trừng phạt&rdquo; (<em>penalize</em>) năng hơn Loss. Việc sử dụng dạng nào còn tùy thuộc vào dataset của bạn. Thực tế thì dạng chuẩn (<em>không bình phương</em>) có vẻ phổ biến hơn 1 chút. Nhưng trong nhiều bài toán,
                    sử dụng dạng bình phương lại cho kết quả tốt hơn. Nói chung, đây sẽ là một <code>hyperparameter</code> mà chúng ta cần phải tuning trong quá trình xây dựng model.</p>
                <p><strong>Ví dụ:</strong></p>
                <p>Để hiểu rõ hơn, hãy cùng xem xét ví dụ sau:</p>


                <div style="text-align:center">
                    <img src="/multi-loss-svm.png" width="600">
                </div>


                <p>Chúng ta có 3 <code>training examples</code> cho 3 nhãn: Dogs, Cats và Pandas. Giả sử ta đã biết giá trị của $W$ và $b$, từ đó sẽ tính được giá trị của Score Fcuntion, như trong hình.</p>
                <p>Tính các $L_i$ cho từng example:</p>
                <p>$L_i(Image 1) = max(0, 1.33 - 4.26 + 1) + max(0, -1.01 - 4.46 + 1) = 0$ $L_i(Image 2) = max(0, 3.76 - (-1.20) + 1) + max(0, -3.81 - (-1.20) + 1) = 5.96$ $L_i(Image 3) = max(0, -2.37 - (-2.27) + 1) + max(0, 1.03 - (-2.27) + 1) = 5.199$</p>
                <p>Ta thấy, $L_i(Image1) = 0$, tức là Image #1 được dự đoán đoán chính xác là Dogs. Điều này cũng hợp lý vì Score của Image #1 đối với nhãn Dogs lớn hơn nhiều so với 2 nhãn còn lại.</p>
                <p>Đối với Image #2 và Image #3, đang được dự đoán là Dogs và Cats, tương ứng. Rõ ràng, đây là dự đoán sai. Nhìn vào $L_i(cats) và L_i(pandas)$ đều &gt; 0, ta thấy khá hợp lý với những dự đoán này.</p>
                <p>Trong bài sau, ta sẽ học các phương pháp tối ưu để tìm ra giá trị của $W$ và $b$ để việc dự đoán sẽ đúng cho cả 3 bức ảnh.</p>
                <p><strong>Tham khảo</strong></p>
                <ul>
                    <li><a href="https://www.pyimagesearch.com/">Pyimagesearch</a></li>
                    <li><a href="https://d2l.ai/chapter_convolutional-neural-networks/index.html">Dive into Deep Learning</a></li>
                    <li><a href="https://cs231n.github.io/convolutional-networks/">CS231</a></li>
                </ul>

            </div>
            <div class="info post_meta">
                <time datetime=2020-11-13T00:00:00Z class="date">Friday, November 13, 2020</time>

                <ul class="tags">

                    <li> <a href="https://tiensu.github.io/tags/ai">AI</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/deep-learning">Deep Learning</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/neural-network">Neural Network</a> </li>

                    <li> <a href="https://tiensu.github.io/tags/cnn">CNN</a> </li>

                </ul>


            </div>
            <div class="clearfix"></div>
        </article>

        <div class="other_posts">

            <a href="https://tiensu.github.io/posts/23_for_book_lover/" class="prev">Dành cho người yêu sách</a>


            <a href="https://tiensu.github.io/posts/25_optimization_methods_gradient-descent/" class="next">Các phương pháp Optimization - Gradient Descent</a>

        </div>
        <aside id="comments">
        </aside>


    </section>

    <a id="back_to_top" title="Go To Top" href="#">
        <span>
    <svg viewBox="0 0 24 24">
      <path fill="none" d="M0 0h24v24H0z"></path>
      <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"></path>
    </svg>
  </span>
    </a>

    <footer id="footer">
        <p>
            <span>&copy; 2020 <a href="https://tiensu.github.io/" title="ML in Practical">ML in Practical</a> </span>
            <span>Built with <a rel="nofollow" target="_blank" href="https://gohugo.io">Hugo</a></span>
            <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/wayjam/hugo-theme-mixedpaper">WayJam</a></span>
        </p>
        <script src="https://tiensu.github.io/js/main.min.8b182175f5874aeed0acc0979345c98d4bde22208ec4f36cc1d6e3102acb4b10.js" integrity="sha256-ixghdfWHSu7QrMCXk0XJjUveIiCOxPNswdbjECrLSxA=" crossorigin="anonymous" async></script>
    </footer>

</body>

</html>